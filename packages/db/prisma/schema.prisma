generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String   @id @default(cuid()) // Unique identifier
  email        String   @unique // Unique email for login
  passwordHash String // Store hashed passwords, never plain text
  role         UserRole @default(SEEKER) // Role determines capabilities (Seeker or Friend)
  createdAt    DateTime @default(now()) // Timestamp for account creation
  updatedAt    DateTime @updatedAt // Timestamp for last update

  // Relationships
  profile          Profile? // One-to-one relationship with Profile
  friendProfile    Friend? // One-to-one relationship if the user is also a Friend
  sessionsAsSeeker Session[] @relation("SeekerSessions") // Sessions where this user is the seeker
  sessionsAsFriend Session[] @relation("FriendSessions") // Sessions where this user is the friend
  reviewsGiven     Review[]  @relation("ReviewsGiven") // Reviews written by this user
  reviewsReceived  Review[]  @relation("ReviewsReceived") // Reviews received by this user (if they are a Friend)
  // Removed payments and subscriptions for MVP
  // payments       Payment[]
  // subscriptions  Subscription[]
  reportsMade      Report[]  @relation("ReportsMade") // Reports filed by this user
  reportsReceived  Report[]  @relation("ReportsReceived") // Reports filed against this user
  blocksMade       Block[]   @relation("BlocksMade") // Users blocked by this user
  blocksReceived   Block[]   @relation("BlocksReceived") // Users who blocked this user

  @@map("users") // Optional: Define the underlying table name
}

// Enum for User Roles
enum UserRole {
  SEEKER // User looking for companionship
  FRIEND // User offering companionship
  ADMIN // Platform administrator (optional)
}

// Enum for Gender Identity
enum Gender {
  MALE
  FEMALE
  NON_BINARY
  OTHER
  PREFER_NOT_TO_SAY
}

// Profile model linked to User, holding common details
model Profile {
  id          String   @id @default(cuid())
  userId      String   @unique // Foreign key linking to the User model
  // If User ID changes (unlikely with cuid), update Profile. If User deleted, delete Profile.
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  displayName String? // Optional display name
  bio         String? // User's biography or description
  gender      Gender? // Optional: User's gender identity
  interests   String[] @default([]) // List of user interests (tags, keywords)
  avatarUrl   String? // URL to the user's avatar image
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("profiles")
}



model Friend {
  id               String      @id @default(cuid())
  userId           String      @unique 
  user             User        @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  // Removed rate fields for MVP
  hourlyRate       Float?
  perMinuteRate    Float?
  availabilityJson String? 
  specialties      String[] @default([]) 
  isVerified       Boolean     @default(false) 
  averageRating    Float       @default(0.0) 
  totalReviews     Int         @default(0)
  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt


  @@map("friends")
}

// --- Interaction & Content Models ---

// Session model tracking interactions between a Seeker and a Friend
model Session {
  id                String            @id @default(cuid())
  seekerId          String 
  // If Seeker User ID changes, update Session. If Seeker User deleted, delete Session.
  seeker            User              @relation("SeekerSessions", fields: [seekerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  friendId          String // Foreign key for the friend User
  // If Friend User ID changes, update Session. If Friend User deleted, delete Session.
  friend            User              @relation("FriendSessions", fields: [friendId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  startTime         DateTime          @default(now()) // When the session started
  endTime           DateTime? // When the session ended (nullable if ongoing)
  durationMinutes   Int? // Calculated duration in minutes
  status            SessionStatus     @default(PENDING) // Status of the session
  communicationType CommunicationType // Type of communication used
  // Removed cost for MVP
  // cost           Float?
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  // Relationships
  reviews Review[] // Reviews associated with this session
  reports Report[]


  @@map("sessions")
}

enum SessionStatus {
  PENDING
  ACTIVE
  COMPLETED
  CANCELLED
  // Removed DISPUTED as it often relates to payments
}

enum CommunicationType {
  CHAT
  VOICE
  VIDEO
}

model Review {
  id         String   @id @default(cuid())
  sessionId  String? // Optional: Link review directly to a session
  // If Session deleted, set sessionId to null (optional). If Session ID changes, update.
  session    Session? @relation(fields: [sessionId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  reviewerId String // Foreign key for the User who wrote the review
  // If Reviewer User ID changes, update Review. If Reviewer User deleted, delete Review.
  reviewer   User     @relation("ReviewsGiven", fields: [reviewerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  friendId   String // Foreign key for the User (Friend) being reviewed
  // If Friend User ID changes, update Review. If Friend User deleted, delete Review.
  friend     User     @relation("ReviewsReceived", fields: [friendId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  rating     Int // Rating score (e.g., 1-5)
  comment    String? // Optional text comment
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt


  @@unique([sessionId, reviewerId]) // Ensure a user reviews a session only once
  @@map("reviews")
}

// --- Payment & Subscription Models ---
// Removed Payment and Subscription models and related enums for MVP

// --- Safety & Moderation Models ---

// Report model for users reporting issues
model Report {
  id             String       @id @default(cuid())
  reporterId     String // Foreign key for the User filing the report
  // If Reporter User ID changes, update Report. If Reporter User deleted, delete Report.
  reporter       User         @relation("ReportsMade", fields: [reporterId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  reportedUserId String // Foreign key for the User being reported
  // If Reported User ID changes, update Report. If Reported User deleted, delete Report.
  reportedUser   User         @relation("ReportsReceived", fields: [reportedUserId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sessionId      String? // Optional: Link report to a specific session
  // If Session deleted, set sessionId to null (optional). If Session ID changes, update.
  session        Session?     @relation(fields: [sessionId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  reason         String // Reason for the report
  details        String? // Additional details
  status         ReportStatus @default(SUBMITTED) // Status of the report review
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  @@map("reports")
}

enum ReportStatus {
  SUBMITTED
  UNDER_REVIEW
  RESOLVED_ACTION_TAKEN
  RESOLVED_NO_ACTION
  DISMISSED
}

// Block model for users blocking each other
model Block {
  id            String   @id @default(cuid())
  blockerId     String // Foreign key for the User initiating the block
  // If Blocker User ID changes, update Block. If Blocker User deleted, delete Block.
  blocker       User     @relation("BlocksMade", fields: [blockerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  blockedUserId String // Foreign key for the User being blocked
  // If Blocked User ID changes, update Block. If Blocked User deleted, delete Block.
  blockedUser   User     @relation("BlocksReceived", fields: [blockedUserId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  createdAt     DateTime @default(now())

  @@unique([blockerId, blockedUserId]) // Prevent duplicate blocks
  @@map("blocks")
}
